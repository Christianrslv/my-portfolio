---
import Layout from '../layouts/Layout.astro';
import Navbar from '../components/Navbar.astro';
import Hero from '../components/Hero.astro';
import About from '../components/About.astro';
import Skills from '../components/Skills.astro';
import Projects from '../components/Projects.astro';
import HorizontalTimeline from '../components/HorizontalTimeline.astro';
import Contact from '../components/Contact.astro';
import Footer from '../components/Footer.astro';
import ScrollIndicator from '../components/ScrollIndicator.astro';
import { portfolioConfig } from '../data/config';
import { getPortfolioContent } from '../utils/content';
import { getPortfolioContentSimple } from '../utils/content-simple';
import { getCollection } from 'astro:content';

// Try multiple methods to load content
let content = null;

// Method 1: Try Content Collections
try {
	console.log('[Index] Attempting Content Collections...');
	const portfolioEntries = await getCollection('portfolio');
	console.log('[Index] Content Collections - entries:', portfolioEntries.length);
	
	if (portfolioEntries.length > 0) {
		content = await getPortfolioContent();
		console.log('[Index] Content Collections loaded:', !!content);
	}
} catch (error) {
	console.warn('[Index] Content Collections failed:', error);
}

// Method 2: Fallback to simple glob loader
if (!content) {
	try {
		console.log('[Index] Trying simple glob loader...');
		content = await getPortfolioContentSimple();
		console.log('[Index] Simple loader result:', !!content);
	} catch (error) {
		console.warn('[Index] Simple loader failed:', error);
	}
}

// Debug logging
console.log('[Index] Content loaded:', !!content);
if (content) {
	console.log('[Index] Using Markdown content');
	console.log('[Index] Hero from content:', content.hero);
} else {
	console.log('[Index] Using config.ts fallback');
}

// Merge content with config fallback
const config = {
	nav: portfolioConfig.nav,
	hero: content?.hero || portfolioConfig.hero,
	about: {
		...portfolioConfig.about,
		...(content?.about || {}),
	},
	skills: content?.skills || portfolioConfig.skills,
	projects: content?.projects || portfolioConfig.projects,
	contact: content?.contact || portfolioConfig.contact,
	footer: portfolioConfig.footer,
};

console.log('[Index] Final hero name:', config.hero.name);
console.log('[Index] Final config.hero:', config.hero);
console.log('[Index] About imageUrl:', config.about.imageUrl);
console.log('[Index] About showImage:', config.about.showImage);
---

<Layout>
	<Navbar logo={config.nav?.logo || portfolioConfig.nav.logo} links={config.nav?.links || portfolioConfig.nav.links} />

	<ScrollIndicator totalSections={6} />

	<div id="scroll-root" class="relative">
		<!-- Test animated ball for scroll progress -->
		<div id="scroll-progress-ball" class="scroll-progress-ball"></div>
		<div 
			id="scroll-stage-bg"
			class="scroll-stage relative h-screen w-full overflow-hidden"
			data-background-image={config.hero.backgroundImage || ''}
		>
			<div class="base-background"></div>
			{config.hero.backgroundImage && (
				<div 
					class="background-image-layer"
					style={`background-image: url('${config.hero.backgroundImage}');`}
				></div>
			)}
			<section id="home" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Hero
					greeting={config.hero.greeting}
					name={config.hero.name}
					role={config.hero.role}
					description={config.hero.description}
					primaryButton={config.hero.primaryButton}
					secondaryButton={config.hero.secondaryButton}
				/>
			</section>

			<section id="about" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<About
					paragraphs={config.about.paragraphs}
					stats={portfolioConfig.about.stats}
				/>
			</section>

			<section id="skills" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Skills categories={config.skills.categories} />
			</section>

			<section id="projects" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Projects projects={config.projects} />
			</section>

		<HorizontalTimeline />

			<section id="contact" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Contact
					description={config.contact.description}
					email={config.contact.email}
					socialLinks={config.contact.socialLinks}
				/>
				<Footer text={portfolioConfig.footer.text} year={portfolioConfig.footer.year} />
			</section>
		</div>
	</div>
</Layout>

<script>
	// @ts-nocheck
	import gsap from 'gsap';
	import ScrollTrigger from 'gsap/ScrollTrigger';

	gsap.registerPlugin(ScrollTrigger);

		function initScrollExperience() {
		const scrollRoot = document.querySelector('#scroll-root');
		const scrollStage = document.querySelector('.scroll-stage');
		const sections = Array.from(document.querySelectorAll('.scroll-panel'));

		if (!scrollRoot || !scrollStage || !sections.length) {
			return;
		}

		console.log('[GSAP] initScrollExperience', { total: sections.length });

		const total = sections.length;
		const SECTION_SCROLL_UNITS = 0.80; // Reduced for faster scrolling
		const TIMELINE_SCROLL_UNITS = 0.75; // Reduced for faster timeline progression
		const SECTION_TOLERANCE = 0.25; // Dead zone at start/end of each section (0-1 range)
		
		
		// Section where background image should be hidden (2 = Skills and beyond)
		const BACKGROUND_IMAGE_END_SECTION = 2;
		const setHeight = () => {
			const timelineSection = sections.find((section) => section.id === 'timeline');
			const timelineEntries = timelineSection
				? parseInt(timelineSection.dataset.timelineEntries || '1', 10)
				: 1;
			const timelineSegments = Math.max(0, timelineEntries - 1);
			const timelineUnits = timelineSegments > 0
				? timelineSegments * TIMELINE_SCROLL_UNITS
				: SECTION_SCROLL_UNITS;
			const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
			const extraUnits = timelineIndex >= 0 ? Math.max(0, timelineUnits - SECTION_SCROLL_UNITS) : 0;
			const totalSegments = (total - 1) * SECTION_SCROLL_UNITS + extraUnits;
			const scrollDistance = (totalSegments + 1) * window.innerHeight;

			scrollRoot.dataset.totalSegments = `${totalSegments}`;
			scrollRoot.dataset.timelineSegments = `${timelineSegments}`;
			scrollRoot.dataset.timelineUnits = `${timelineUnits}`;
			scrollRoot.dataset.timelineExtraUnits = `${extraUnits}`;
			scrollRoot.style.height = `${scrollDistance}px`;
			console.log('[GSAP] scrollRoot height set', {
				scrollDistance,
				totalSegments,
				timelineSegments,
				timelineUnits,
				extraUnits,
				timelineEntries,
				SECTION_SCROLL_UNITS,
				TIMELINE_SCROLL_UNITS
			});
			return scrollDistance;
		};

		let scrollDistance = setHeight();

		sections.forEach((section, index) => {
			const xOffset = index % 2 === 0 ? -60 : 60;
			gsap.set(section, {
				autoAlpha: 0,
				y: 40,
				x: xOffset,
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
			});
		});
		gsap.set(sections[0], { autoAlpha: 1, y: 0, x: 0 });

		// Initialize scroll progress ball
		const progressBall = document.getElementById('scroll-progress-ball');
		if (progressBall) {
			gsap.set(progressBall, { x: 0, y: 50 });
		}

		let activeIndex = 0;

		const updateProgress = (exactProgress) => {
			// Use threshold-based discrete switching like the timeline
			// Calculate which section should be active based on progress with tolerance
			const rawFrac = exactProgress - Math.floor(exactProgress);
			let targetIndex = Math.floor(exactProgress);
			
			// Apply tolerance: only switch to next section after crossing the threshold
			// This creates discrete sections that don't overlap
			if (rawFrac < SECTION_TOLERANCE) {
				// In the start tolerance zone: stay at current section
				targetIndex = Math.floor(exactProgress);
			} else if (rawFrac > 1 - SECTION_TOLERANCE) {
				// In the end tolerance zone: switch to next section
				targetIndex = Math.min(total - 1, Math.floor(exactProgress) + 1);
			} else {
				// In the transition zone: determine based on midpoint
				targetIndex = rawFrac < 0.5 
					? Math.floor(exactProgress)
					: Math.min(total - 1, Math.floor(exactProgress) + 1);
			}
			
			// Clamp to valid range
			targetIndex = Math.max(0, Math.min(total - 1, targetIndex));

			// Only update sections when the target index changes (discrete switching)
			if (targetIndex !== activeIndex) {
				activeIndex = targetIndex;
				
				// Hide all sections first
				sections.forEach((section, i) => {
					const xOffset = i % 2 === 0 ? -60 : 60;
					if (i === activeIndex) {
						// Show active section
						gsap.to(section, {
							autoAlpha: 1,
							y: 0,
							x: 0,
							duration: 0.3,
							ease: 'power2.out',
							overwrite: true,
						});
					} else {
						// Hide inactive sections
						gsap.to(section, {
							autoAlpha: 0,
							y: 40,
							x: xOffset,
							duration: 0.3,
							ease: 'power2.out',
							overwrite: true,
						});
					}
				});

				window.dispatchEvent(new CustomEvent('sectionchange', {
					detail: { index: activeIndex }
				}));
			}
		};

		ScrollTrigger.create({
			trigger: scrollRoot,
			start: 'top top',
			end: () => `+=${scrollDistance - window.innerHeight}`,
			scrub: 2, // Increased for smoother, slower transitions
			pin: scrollStage,
			anticipatePin: 1,
			snap: false,
			onUpdate: (self) => {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineExtraUnits = parseInt(
					scrollRoot.dataset.timelineExtraUnits || '0',
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const timelineLength = timelineIndex >= 0 ? timelineUnits : SECTION_SCROLL_UNITS;

				const exactProgress = self.progress * totalSegments;
				let mappedProgress = exactProgress / SECTION_SCROLL_UNITS;
				let timelineProgress = 0;

				if (timelineIndex >= 0) {
					const timelineStart = timelineIndex * SECTION_SCROLL_UNITS;
					const timelineEnd = timelineStart + timelineLength;

					if (exactProgress < timelineStart) {
						// Before timeline: normal section progression
						mappedProgress = exactProgress / SECTION_SCROLL_UNITS;
						timelineProgress = 0;
					} else if (exactProgress >= timelineStart && exactProgress <= timelineEnd) {
						// During timeline: keep section index at timeline, only update timeline progress
						timelineProgress = (exactProgress - timelineStart) / timelineLength;
						// Keep mappedProgress at timelineIndex during the entire timeline scroll
						// Only start transitioning to next section at the very end
						const transitionStart = timelineEnd - SECTION_SCROLL_UNITS;
						if (exactProgress < transitionStart) {
							mappedProgress = timelineIndex;
						} else {
							// Transition to next section in the last SECTION_SCROLL_UNITS of timeline
							const transitionProgress = (exactProgress - transitionStart) / SECTION_SCROLL_UNITS;
							mappedProgress = timelineIndex + transitionProgress;
						}
					} else {
						// After timeline: account for extra units and continue normal progression
						mappedProgress = (exactProgress - timelineExtraUnits) / SECTION_SCROLL_UNITS;
						timelineProgress = 1;
					}
				}

				// Clamp mappedProgress to ensure we can reach all sections
				const clampedMappedProgress = Math.max(0, Math.min(total - 1, mappedProgress));
				const clampedTimelineProgress = Math.max(0, Math.min(1, timelineProgress));
				
				// Animate background focal point and handle image visibility
				const backgroundStage = document.getElementById('scroll-stage-bg');
				const backgroundImageLayer = backgroundStage?.querySelector('.background-image-layer');
				const hasBackground = backgroundStage?.dataset.backgroundImage;
				if (backgroundImageLayer && hasBackground) {
					const currentSection = Math.floor(clampedMappedProgress);
					const sectionProgress = clampedMappedProgress - currentSection;
					// Keep the image aligned to right/bottom with cover sizing.
					// Cropping is allowed on top/left to preserve aspect ratio.
					backgroundImageLayer.style.backgroundPosition = 'right bottom';
					
					// Zoom behavior: completes by 70% through section 0 (before section 1 content appears)
					const zoomStart = 1.0;
					const zoomEnd = 1.5;
					const zoomProgress = currentSection === 0
						? Math.min(1, sectionProgress / 0.7) // Complete zoom by 70% of section 0
						: 1;
					const zoomScale = zoomStart + (zoomEnd - zoomStart) * zoomProgress;

					// Exit animation: image slides left and fades out during section 1
					// Starts immediately at section 1, completes by 60% (before section 2 content appears)
					const exitProgress = currentSection === 1
						? Math.min(1, sectionProgress / 0.6)
						: (currentSection >= 2 ? 1 : 0);
					
					// Image slides left as it exits - always apply based on exit progress
					// No rightward movement ever - exitTranslate is always 0 or negative
					const exitTranslate = exitProgress * -40; // vw, negative = left

					backgroundImageLayer.style.transform = `translateX(${exitTranslate}vw) scale(${zoomScale})`;

					// Handle opacity based on section
					// Section 0: overlay fades from 0.85 to 1.0 (filter disappears as we scroll)
					// Section 1: full opacity (no filter), then fade out during exit
					if (currentSection >= BACKGROUND_IMAGE_END_SECTION) {
						// Completely hidden starting at section 2 (Skills)
						backgroundImageLayer.style.opacity = '0';
						backgroundImageLayer.style.visibility = 'hidden';
					} else if (currentSection === 1) {
						// No filter initially (1.0), fade out during exit
						const fadeOpacity = 1 - exitProgress;
						backgroundImageLayer.style.opacity = `${fadeOpacity}`;
						backgroundImageLayer.style.visibility = fadeOpacity > 0.01 ? 'visible' : 'hidden';
					} else {
						// Section 0: overlay fades from 0.85 to 1.0 as we progress through the section
						// By the end of section 0, opacity is 1.0 (no filter)
						const overlayOpacity = 0.85 + (0.15 * sectionProgress);
						backgroundImageLayer.style.opacity = `${overlayOpacity}`;
						backgroundImageLayer.style.visibility = 'visible';
					}
				}
				
				console.log('[GSAP] progress', self.progress.toFixed(3), 'exact', exactProgress.toFixed(2), 'mapped', clampedMappedProgress.toFixed(2), 'timeline', clampedTimelineProgress.toFixed(3));
				updateProgress(clampedMappedProgress);

				// Update animated ball based on scroll progress (like timeline progress bar)
				const progressBall = document.getElementById('scroll-progress-ball');
				if (progressBall) {
					const scrollProgress = self.progress; // 0 to 1
					// Animate ball position horizontally across the screen
					const maxX = window.innerWidth - 60; // Account for ball width
					const xPosition = scrollProgress * maxX;
					// Also add some vertical movement for visual interest
					const yPosition = 50 + Math.sin(scrollProgress * Math.PI * 4) * 30;
					
					gsap.to(progressBall, {
						x: xPosition,
						y: yPosition,
						duration: 0.1,
						ease: 'none',
						overwrite: true,
					});
				}

				if (timelineIndex >= 0) {
					window.dispatchEvent(new CustomEvent('timelineprogress', {
						detail: { progress: clampedTimelineProgress }
					}));
				}
			},
		});

		window.addEventListener('resize', () => {
			scrollDistance = setHeight();
			ScrollTrigger.refresh();
		});

		// Nav link handling
		document.addEventListener('click', (e) => {
			const target = e.target;
			const anchor = target && target.closest ? target.closest('a[href^="#"]') : null;
			if (!anchor) return;
			e.preventDefault();
			const href = anchor.getAttribute('href') || '';
			const targetId = href.replace('#', '');
			const targetIndex = sections.findIndex((section) => section.id === targetId);
			if (targetIndex !== -1) {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const extraUnits = Math.max(0, timelineUnits - SECTION_SCROLL_UNITS);
				const step = (scrollDistance - window.innerHeight) / totalSegments;
				const segment = timelineIndex >= 0 && targetIndex > timelineIndex
					? targetIndex * SECTION_SCROLL_UNITS + extraUnits
					: targetIndex * SECTION_SCROLL_UNITS;
				window.scrollTo({
					top: step * segment,
					behavior: 'smooth',
				});
			}
		});

		window.addEventListener('gotosection', (e) => {
			const detail = e.detail || {};
			if (typeof detail.index === 'number') {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const extraUnits = Math.max(0, timelineUnits - SECTION_SCROLL_UNITS);
				const step = (scrollDistance - window.innerHeight) / totalSegments;
				const segment = timelineIndex >= 0 && detail.index > timelineIndex
					? detail.index * SECTION_SCROLL_UNITS + extraUnits
					: detail.index * SECTION_SCROLL_UNITS;
				window.scrollTo({
					top: step * segment,
					behavior: 'smooth',
				});
			}
		});
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initScrollExperience);
	} else {
		setTimeout(initScrollExperience, 50);
	}
</script>

<style>
	#scroll-root {
		position: relative;
	}

	.scroll-stage {
		position: relative;
		width: 100%;
		height: 100vh;
		overflow: hidden;
	}

	/* Base background - shows when image moves/zooms or is hidden */
	.base-background {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: #FFFFFF;
		z-index: 0;
	}

	html.dark .base-background {
		background: #0F172A;
	}

	/* Background image layer - on top of base background */
	.background-image-layer {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		width: 100%;
		height: 100%;
		background-size: cover;
		background-position: right bottom;
		background-repeat: no-repeat;
		transform-origin: right bottom;
		z-index: 1;
		pointer-events: none;
		transition: transform 0.15s linear, opacity 0.3s ease;
	}


	.scroll-panel {
		min-height: 100vh;
		width: 100%;
		display: flex;
		align-items: flex-start;
		justify-content: flex-start;
		position: relative;
		z-index: 10;
	}

	/* Override default section fade for this experience */
	.scroll-panel .section {
		opacity: 1 !important;
		transform: none !important;
	}

	/* Test animated ball for scroll progress */
	.scroll-progress-ball {
		position: fixed;
		top: 50px;
		left: 0;
		width: 60px;
		height: 60px;
		border-radius: 50%;
		background: var(--accent-primary);
		box-shadow: 0 0 20px rgba(100, 116, 139, 0.3);
		z-index: 9999;
		pointer-events: none;
		transform: translate(0, 0);
		opacity: 0.8;
	}

	html.dark .scroll-progress-ball {
		box-shadow: 0 0 20px rgba(96, 165, 250, 0.3);
	}
</style>
