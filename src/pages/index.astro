---
import Layout from '../layouts/Layout.astro';
import Navbar from '../components/Navbar.astro';
import Hero from '../components/Hero.astro';
import About from '../components/About.astro';
import Skills from '../components/Skills.astro';
import Projects from '../components/Projects.astro';
import HorizontalTimeline from '../components/HorizontalTimeline.astro';
import Contact from '../components/Contact.astro';
import Footer from '../components/Footer.astro';
import ScrollIndicator from '../components/ScrollIndicator.astro';
import { portfolioConfig } from '../data/config';
import { getPortfolioContent } from '../utils/content';
import { getPortfolioContentSimple } from '../utils/content-simple';
import { getCollection } from 'astro:content';

// Try multiple methods to load content
let content = null;

// Method 1: Try Content Collections
try {
	console.log('[Index] Attempting Content Collections...');
	const portfolioEntries = await getCollection('portfolio');
	console.log('[Index] Content Collections - entries:', portfolioEntries.length);
	
	if (portfolioEntries.length > 0) {
		content = await getPortfolioContent();
		console.log('[Index] Content Collections loaded:', !!content);
	}
} catch (error) {
	console.warn('[Index] Content Collections failed:', error);
}

// Method 2: Fallback to simple glob loader
if (!content) {
	try {
		console.log('[Index] Trying simple glob loader...');
		content = await getPortfolioContentSimple();
		console.log('[Index] Simple loader result:', !!content);
	} catch (error) {
		console.warn('[Index] Simple loader failed:', error);
	}
}

// Debug logging
console.log('[Index] Content loaded:', !!content);
if (content) {
	console.log('[Index] Using Markdown content');
	console.log('[Index] Hero from content:', content.hero);
} else {
	console.log('[Index] Using config.ts fallback');
}

// Merge content with config fallback
const config = {
	nav: portfolioConfig.nav,
	hero: content?.hero || portfolioConfig.hero,
	about: {
		...portfolioConfig.about,
		...(content?.about || {}),
	},
	skills: content?.skills || portfolioConfig.skills,
	projects: content?.projects || portfolioConfig.projects,
	contact: content?.contact || portfolioConfig.contact,
	footer: portfolioConfig.footer,
};

console.log('[Index] Final hero name:', config.hero.name);
console.log('[Index] Final config.hero:', config.hero);
console.log('[Index] About imageUrl:', config.about.imageUrl);
console.log('[Index] About showImage:', config.about.showImage);
---

<Layout>
	<Navbar logo={config.nav?.logo || portfolioConfig.nav.logo} links={config.nav?.links || portfolioConfig.nav.links} />

	<ScrollIndicator totalSections={6} />

	<div id="scroll-root" class="relative">
		<!-- Test animated ball for scroll progress -->
		<div id="scroll-progress-ball" class="scroll-progress-ball"></div>
		<div 
			id="scroll-stage-bg"
			class="scroll-stage relative h-screen w-full overflow-hidden"
			data-background-image={config.hero.backgroundImage || ''}
		>
			<div class="base-background"></div>
			{config.hero.backgroundImage && (
				<>
					<div 
						class="background-image-layer"
						style={`background-image: url('${config.hero.backgroundImage}');`}
					></div>
					<!-- Full overlay for Section 0 -->
					<div class="overlay-full"></div>
					<!-- Gradient overlay for Section 1 (left side dark, right side transparent) -->
					<div class="overlay-gradient"></div>
				</>
			)}
			<section id="home" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Hero
					greeting={config.hero.greeting}
					name={config.hero.name}
					role={config.hero.role}
					description={config.hero.description}
					primaryButton={config.hero.primaryButton}
					secondaryButton={config.hero.secondaryButton}
				/>
			</section>

			<section id="about" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<About
					paragraphs={config.about.paragraphs}
					stats={portfolioConfig.about.stats}
				/>
			</section>

			<section id="skills" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Skills categories={config.skills.categories} />
			</section>

			<section id="projects" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Projects projects={config.projects} />
			</section>

		<HorizontalTimeline />

			<section id="contact" class="scroll-panel flex min-h-screen w-full items-center justify-center">
				<Contact
					description={config.contact.description}
					email={config.contact.email}
					socialLinks={config.contact.socialLinks}
				/>
				<Footer text={portfolioConfig.footer.text} year={portfolioConfig.footer.year} />
			</section>
		</div>
	</div>
</Layout>

<script>
	// @ts-nocheck
	import gsap from 'gsap';
	import ScrollTrigger from 'gsap/ScrollTrigger';

	gsap.registerPlugin(ScrollTrigger);

		// Check if we're on mobile (card stacking mode)
		const isMobile = () => window.innerWidth <= 1024;

		function initScrollExperience() {
		const scrollRoot = document.querySelector('#scroll-root');
		const scrollStage = document.querySelector('.scroll-stage');
		const sections = Array.from(document.querySelectorAll('.scroll-panel'));

		if (!scrollRoot || !scrollStage || !sections.length) {
			return;
		}

		// On mobile, use CSS-based card stacking instead of GSAP
		if (isMobile()) {
			console.log('[GSAP] Mobile detected - using CSS card stacking');
			
			// Reset any GSAP-applied styles for mobile
			sections.forEach((section) => {
				gsap.set(section, {
					clearProps: 'all'
				});
			});
			
			// Ensure scroll root height is auto for mobile
			scrollRoot.style.height = 'auto';
			
			return; // Skip GSAP scroll experience on mobile
		}

		console.log('[GSAP] Desktop detected - initializing GSAP scroll experience');
		console.log('[GSAP] initScrollExperience', { total: sections.length });

		const total = sections.length;
		const SECTION_SCROLL_UNITS = 0.80; // Reduced for faster scrolling
		const TIMELINE_SCROLL_UNITS = 0.75; // Reduced for faster timeline progression
		const SECTION_TOLERANCE = 0.25; // Dead zone at start/end of each section (0-1 range)
		
		
		// Section where background image should be hidden (2 = Skills and beyond)
		const BACKGROUND_IMAGE_END_SECTION = 2;
		const setHeight = () => {
			const timelineSection = sections.find((section) => section.id === 'timeline');
			const timelineEntries = timelineSection
				? parseInt(timelineSection.dataset.timelineEntries || '1', 10)
				: 1;
			const timelineSegments = Math.max(0, timelineEntries - 1);
			const timelineUnits = timelineSegments > 0
				? timelineSegments * TIMELINE_SCROLL_UNITS
				: SECTION_SCROLL_UNITS;
			const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
			const extraUnits = timelineIndex >= 0 ? Math.max(0, timelineUnits - SECTION_SCROLL_UNITS) : 0;
			const totalSegments = (total - 1) * SECTION_SCROLL_UNITS + extraUnits;
			const scrollDistance = (totalSegments + 1) * window.innerHeight;

			scrollRoot.dataset.totalSegments = `${totalSegments}`;
			scrollRoot.dataset.timelineSegments = `${timelineSegments}`;
			scrollRoot.dataset.timelineUnits = `${timelineUnits}`;
			scrollRoot.dataset.timelineExtraUnits = `${extraUnits}`;
			scrollRoot.style.height = `${scrollDistance}px`;
			console.log('[GSAP] scrollRoot height set', {
				scrollDistance,
				totalSegments,
				timelineSegments,
				timelineUnits,
				extraUnits,
				timelineEntries,
				SECTION_SCROLL_UNITS,
				TIMELINE_SCROLL_UNITS
			});
			return scrollDistance;
		};

		let scrollDistance = setHeight();

		sections.forEach((section, index) => {
			const xOffset = index % 2 === 0 ? -60 : 60;
			gsap.set(section, {
				autoAlpha: 0,
				y: 40,
				x: xOffset,
				position: 'absolute',
				top: 0,
				left: 0,
				width: '100%',
			});
		});
		gsap.set(sections[0], { autoAlpha: 1, y: 0, x: 0 });

		// Initialize scroll progress ball
		const progressBall = document.getElementById('scroll-progress-ball');
		if (progressBall) {
			gsap.set(progressBall, { x: 0, y: 50 });
		}

		let activeIndex = 0;

		const updateProgress = (exactProgress) => {
			// Use threshold-based discrete switching like the timeline
			// Calculate which section should be active based on progress with tolerance
			const rawFrac = exactProgress - Math.floor(exactProgress);
			let targetIndex = Math.floor(exactProgress);
			
			// Apply tolerance: only switch to next section after crossing the threshold
			// This creates discrete sections that don't overlap
			if (rawFrac < SECTION_TOLERANCE) {
				// In the start tolerance zone: stay at current section
				targetIndex = Math.floor(exactProgress);
			} else if (rawFrac > 1 - SECTION_TOLERANCE) {
				// In the end tolerance zone: switch to next section
				targetIndex = Math.min(total - 1, Math.floor(exactProgress) + 1);
			} else {
				// In the transition zone: determine based on midpoint
				targetIndex = rawFrac < 0.5 
					? Math.floor(exactProgress)
					: Math.min(total - 1, Math.floor(exactProgress) + 1);
			}
			
			// Clamp to valid range
			targetIndex = Math.max(0, Math.min(total - 1, targetIndex));

			// Only update sections when the target index changes (discrete switching)
			if (targetIndex !== activeIndex) {
				activeIndex = targetIndex;
				
				// Hide all sections first
				sections.forEach((section, i) => {
					const xOffset = i % 2 === 0 ? -60 : 60;
					if (i === activeIndex) {
						// Show active section
						gsap.to(section, {
							autoAlpha: 1,
							y: 0,
							x: 0,
							duration: 0.3,
							ease: 'power2.out',
							overwrite: true,
						});
					} else {
						// Hide inactive sections
						gsap.to(section, {
							autoAlpha: 0,
							y: 40,
							x: xOffset,
							duration: 0.3,
							ease: 'power2.out',
							overwrite: true,
						});
					}
				});

				window.dispatchEvent(new CustomEvent('sectionchange', {
					detail: { index: activeIndex }
				}));
			}
		};

		ScrollTrigger.create({
			trigger: scrollRoot,
			start: 'top top',
			end: () => `+=${scrollDistance - window.innerHeight}`,
			scrub: 2, // Increased for smoother, slower transitions
			pin: scrollStage,
			anticipatePin: 1,
			snap: false,
			onUpdate: (self) => {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineExtraUnits = parseInt(
					scrollRoot.dataset.timelineExtraUnits || '0',
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const timelineLength = timelineIndex >= 0 ? timelineUnits : SECTION_SCROLL_UNITS;

				const exactProgress = self.progress * totalSegments;
				let mappedProgress = exactProgress / SECTION_SCROLL_UNITS;
				let timelineProgress = 0;

				if (timelineIndex >= 0) {
					const timelineStart = timelineIndex * SECTION_SCROLL_UNITS;
					const timelineEnd = timelineStart + timelineLength;

					if (exactProgress < timelineStart) {
						// Before timeline: normal section progression
						mappedProgress = exactProgress / SECTION_SCROLL_UNITS;
						timelineProgress = 0;
					} else if (exactProgress >= timelineStart && exactProgress <= timelineEnd) {
						// During timeline: keep section index at timeline, only update timeline progress
						timelineProgress = (exactProgress - timelineStart) / timelineLength;
						// Keep mappedProgress at timelineIndex during the entire timeline scroll
						// Only start transitioning to next section at the very end
						const transitionStart = timelineEnd - SECTION_SCROLL_UNITS;
						if (exactProgress < transitionStart) {
							mappedProgress = timelineIndex;
						} else {
							// Transition to next section in the last SECTION_SCROLL_UNITS of timeline
							const transitionProgress = (exactProgress - transitionStart) / SECTION_SCROLL_UNITS;
							mappedProgress = timelineIndex + transitionProgress;
						}
					} else {
						// After timeline: account for extra units and continue normal progression
						mappedProgress = (exactProgress - timelineExtraUnits) / SECTION_SCROLL_UNITS;
						timelineProgress = 1;
					}
				}

				// Clamp mappedProgress to ensure we can reach all sections
				const clampedMappedProgress = Math.max(0, Math.min(total - 1, mappedProgress));
				const clampedTimelineProgress = Math.max(0, Math.min(1, timelineProgress));
				
				// Animate background focal point and handle image/overlay visibility
				const backgroundStage = document.getElementById('scroll-stage-bg');
				const backgroundImageLayer = backgroundStage?.querySelector('.background-image-layer');
				const overlayFull = backgroundStage?.querySelector('.overlay-full');
				const overlayGradient = backgroundStage?.querySelector('.overlay-gradient');
				const hasBackground = backgroundStage?.dataset.backgroundImage;
				
				if (backgroundImageLayer && hasBackground) {
					const currentSection = Math.floor(clampedMappedProgress);
					const sectionProgress = clampedMappedProgress - currentSection;
					// Keep the image aligned to right/bottom with cover sizing.
					// Cropping is allowed on top/left to preserve aspect ratio.
					backgroundImageLayer.style.backgroundPosition = 'right bottom';
					
					// Zoom behavior: completes by 70% through section 0 (before section 1 content appears)
					// Only apply zoom on desktop (>= 1024px)
					const isDesktop = window.innerWidth >= 1024;
					const zoomStart = 1.0;
					const zoomEnd = 1.5;
					const zoomProgress = currentSection === 0
						? Math.min(1, sectionProgress / 0.7) // Complete zoom by 70% of section 0
						: 1;
					const zoomScale = isDesktop ? zoomStart + (zoomEnd - zoomStart) * zoomProgress : 1.0;

					// Exit animation: image slides left and fades out during section 1
					// Starts immediately at section 1, completes by 60% (before section 2 content appears)
					const exitProgress = currentSection === 1
						? Math.min(1, sectionProgress / 0.6)
						: (currentSection >= 2 ? 1 : 0);
					
					// Image slides left as it exits - always apply based on exit progress
					// No rightward movement ever - exitTranslate is always 0 or negative
					const exitTranslate = exitProgress * -40; // vw, negative = left

					backgroundImageLayer.style.transform = `translateX(${exitTranslate}vw) scale(${zoomScale})`;

					// ============================================
					// OVERLAY ANIMATION SYSTEM
					// ============================================
					// Section 0: Full overlay transitions to gradient overlay AS ZOOM PROGRESSES
					//   - Zoom completes at 70% through section 0
					//   - By zoom completion, full overlay is gone, gradient is fully visible
					//   - Right side of screen is clear (no overlay) once zoom is done
					// Section 1: Gradient overlay visible, fades out with exit animation
					// Section 2+: Everything hidden
					// ============================================
					
					// Overlay transition synced with zoom (completes when zoom completes at 70% of section 0)
					const overlayTransitionProgress = currentSection === 0 
						? zoomProgress  // Synced with zoom (0 to 1 as zoom completes)
						: 1;            // Fully transitioned in section 1+
					
					if (currentSection >= BACKGROUND_IMAGE_END_SECTION) {
						// Section 2+: Hide everything
						backgroundImageLayer.style.opacity = '0';
						backgroundImageLayer.style.visibility = 'hidden';
						if (overlayFull) {
							overlayFull.style.opacity = '0';
							overlayFull.style.visibility = 'hidden';
						}
						if (overlayGradient) {
							overlayGradient.style.opacity = '0';
							overlayGradient.style.visibility = 'hidden';
						}
					} else if (currentSection === 1) {
						// Section 1: Gradient overlay visible, fades out with exit animation
						const imageOpacity = 1 - exitProgress;
						backgroundImageLayer.style.opacity = `${imageOpacity}`;
						backgroundImageLayer.style.visibility = imageOpacity > 0.01 ? 'visible' : 'hidden';
						
						// Full overlay: already gone by section 1
						if (overlayFull) {
							overlayFull.style.opacity = '0';
							overlayFull.style.visibility = 'hidden';
						}
						
						// Gradient overlay: visible, fades out with exit
						if (overlayGradient) {
							const gradientOpacity = 1 - exitProgress;
							overlayGradient.style.opacity = `${gradientOpacity}`;
							overlayGradient.style.visibility = gradientOpacity > 0.01 ? 'visible' : 'hidden';
						}
					} else {
						// Section 0: Transition from full overlay to gradient as zoom progresses
						backgroundImageLayer.style.opacity = '1';
						backgroundImageLayer.style.visibility = 'visible';
						
						// Full overlay: fades out as zoom progresses
						if (overlayFull) {
							const fullOverlayOpacity = 1 - overlayTransitionProgress;
							overlayFull.style.opacity = `${fullOverlayOpacity}`;
							overlayFull.style.visibility = fullOverlayOpacity > 0.01 ? 'visible' : 'hidden';
						}
						
						// Gradient overlay: fades in as zoom progresses
						if (overlayGradient) {
							overlayGradient.style.opacity = `${overlayTransitionProgress}`;
							overlayGradient.style.visibility = overlayTransitionProgress > 0.01 ? 'visible' : 'hidden';
						}
					}
				}
				
				console.log('[GSAP] progress', self.progress.toFixed(3), 'exact', exactProgress.toFixed(2), 'mapped', clampedMappedProgress.toFixed(2), 'timeline', clampedTimelineProgress.toFixed(3));
				updateProgress(clampedMappedProgress);

				// Update animated ball based on scroll progress (like timeline progress bar)
				const progressBall = document.getElementById('scroll-progress-ball');
				if (progressBall) {
					const scrollProgress = self.progress; // 0 to 1
					// Animate ball position horizontally across the screen
					const maxX = window.innerWidth - 60; // Account for ball width
					const xPosition = scrollProgress * maxX;
					// Also add some vertical movement for visual interest
					const yPosition = 50 + Math.sin(scrollProgress * Math.PI * 4) * 30;
					
					gsap.to(progressBall, {
						x: xPosition,
						y: yPosition,
						duration: 0.1,
						ease: 'none',
						overwrite: true,
					});
				}

				if (timelineIndex >= 0) {
					window.dispatchEvent(new CustomEvent('timelineprogress', {
						detail: { progress: clampedTimelineProgress }
					}));
				}
			},
		});

		window.addEventListener('resize', () => {
			scrollDistance = setHeight();
			ScrollTrigger.refresh();
		});

		// Nav link handling
		document.addEventListener('click', (e) => {
			const target = e.target;
			const anchor = target && target.closest ? target.closest('a[href^="#"]') : null;
			if (!anchor) return;
			e.preventDefault();
			const href = anchor.getAttribute('href') || '';
			const targetId = href.replace('#', '');
			const targetIndex = sections.findIndex((section) => section.id === targetId);
			if (targetIndex !== -1) {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const extraUnits = Math.max(0, timelineUnits - SECTION_SCROLL_UNITS);
				const step = (scrollDistance - window.innerHeight) / totalSegments;
				const segment = timelineIndex >= 0 && targetIndex > timelineIndex
					? targetIndex * SECTION_SCROLL_UNITS + extraUnits
					: targetIndex * SECTION_SCROLL_UNITS;
				window.scrollTo({
					top: step * segment,
					behavior: 'smooth',
				});
			}
		});

		window.addEventListener('gotosection', (e) => {
			const detail = e.detail || {};
			if (typeof detail.index === 'number') {
				const totalSegments = parseInt(
					scrollRoot.dataset.totalSegments || `${(total - 1) * SECTION_SCROLL_UNITS}`,
					10
				);
				const timelineSegments = parseInt(scrollRoot.dataset.timelineSegments || '1', 10);
				const timelineUnits = parseInt(
					scrollRoot.dataset.timelineUnits || `${timelineSegments * TIMELINE_SCROLL_UNITS}`,
					10
				);
				const timelineIndex = sections.findIndex((section) => section.id === 'timeline');
				const extraUnits = Math.max(0, timelineUnits - SECTION_SCROLL_UNITS);
				const step = (scrollDistance - window.innerHeight) / totalSegments;
				const segment = timelineIndex >= 0 && detail.index > timelineIndex
					? detail.index * SECTION_SCROLL_UNITS + extraUnits
					: detail.index * SECTION_SCROLL_UNITS;
				window.scrollTo({
					top: step * segment,
					behavior: 'smooth',
				});
			}
		});
	}

	// Track current mode to detect changes
	let currentMode = isMobile() ? 'mobile' : 'desktop';
	let scrollTriggerInstance = null;

	function init() {
		initScrollExperience();
	}

	// Handle resize to switch between mobile and desktop modes
	function handleResize() {
		const newMode = isMobile() ? 'mobile' : 'desktop';
		
		if (newMode !== currentMode) {
			console.log(`[GSAP] Mode changed: ${currentMode} -> ${newMode}`);
			currentMode = newMode;
			
			// Kill existing ScrollTrigger instances
			ScrollTrigger.getAll().forEach(st => st.kill());
			
			// Re-initialize with new mode
			initScrollExperience();
		}
	}

	// Debounced resize handler
	let resizeTimeout;
	window.addEventListener('resize', () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(handleResize, 150);
	});

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', init);
	} else {
		setTimeout(init, 50);
	}

	// Mobile scroll handler for background fade
	// Matches desktop behavior: overlay transitions during Hero, background fades when entering Skills
	function initMobileBackgroundFade() {
		if (!isMobile()) return;
		
		const backgroundImageLayer = document.querySelector('.background-image-layer');
		const overlayFull = document.querySelector('.overlay-full');
		const overlayGradient = document.querySelector('.overlay-gradient');
		const baseBackground = document.querySelector('.base-background');
		const heroSection = document.getElementById('home');
		const aboutSection = document.getElementById('about');
		const skillsSection = document.getElementById('skills');
		
		if (!heroSection || !aboutSection) return;

		function updateBackgroundOnScroll() {
			if (!isMobile()) return;
			
			const scrollY = window.scrollY;
			const heroHeight = heroSection.offsetHeight;
			const aboutTop = aboutSection.offsetTop;
			const aboutHeight = aboutSection.offsetHeight;
			const skillsTop = skillsSection ? skillsSection.offsetTop : aboutTop + aboutHeight;
			
			// Phase 1: Overlay transition (during Hero section)
			// Full overlay transitions to gradient overlay by 70% of Hero scroll
			const overlayTransitionEnd = heroHeight * 0.7;
			
			let overlayProgress = 0;
			if (scrollY > 0 && scrollY < overlayTransitionEnd) {
				overlayProgress = scrollY / overlayTransitionEnd;
			} else if (scrollY >= overlayTransitionEnd) {
				overlayProgress = 1;
			}
			
			// Phase 2: Background fade out (when Skills section starts covering About)
			// Background stays visible through Hero and About, fades when entering Skills
			const fadeStart = aboutTop + (aboutHeight * 0.5);
			const fadeEnd = skillsTop + (window.innerHeight * 0.3);
			
			let fadeProgress = 0;
			if (scrollY > fadeStart) {
				fadeProgress = Math.min(1, (scrollY - fadeStart) / (fadeEnd - fadeStart));
			}
			
			// Apply overlay transitions (same as desktop)
			if (overlayFull) {
				const fullOpacity = (1 - overlayProgress) * (1 - fadeProgress);
				overlayFull.style.opacity = String(Math.max(0, fullOpacity));
				overlayFull.style.visibility = fullOpacity > 0.01 ? 'visible' : 'hidden';
			}
			
			if (overlayGradient) {
				const gradientOpacity = overlayProgress * (1 - fadeProgress);
				overlayGradient.style.opacity = String(Math.max(0, gradientOpacity));
				overlayGradient.style.visibility = gradientOpacity > 0.01 ? 'visible' : 'hidden';
			}
			
			// Fade out background image when entering Skills
			if (backgroundImageLayer) {
				const bgOpacity = 1 - fadeProgress;
				backgroundImageLayer.style.opacity = String(Math.max(0, bgOpacity));
				backgroundImageLayer.style.visibility = bgOpacity > 0.01 ? 'visible' : 'hidden';
			}
			
			// Base background stays visible
			if (baseBackground) {
				baseBackground.style.opacity = '1';
			}
		}

		window.addEventListener('scroll', updateBackgroundOnScroll, { passive: true });
		updateBackgroundOnScroll(); // Initial call
	}

	// Initialize mobile background fade
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initMobileBackgroundFade);
	} else {
		initMobileBackgroundFade();
	}
</script>

<style>
	#scroll-root {
		position: relative;
	}

	.scroll-stage {
		position: relative;
		width: 100%;
		height: 100vh;
		overflow: hidden;
	}

	/* Base background - shows when image moves/zooms or is hidden */
	.base-background {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: linear-gradient(
			135deg,
			#a8cce3 0%,
			#b5d4e8 20%,
			#d4e9f2 40%,
			#c8e0ed 60%,
			#b5d4e8 80%,
			#a8cce3 100%
		);
		background-size: 300% 300%;
		animation: baseGradientShift 12s ease-in-out infinite;
		z-index: 0;
	}

	html.dark .base-background {
		background: linear-gradient(
			135deg,
			#070d17 0%,
			#0a1628 20%,
			#131d32 40%,
			#0f172a 60%,
			#0a1628 80%,
			#070d17 100%
		);
		background-size: 300% 300%;
		animation: baseGradientShift 12s ease-in-out infinite;
	}

	@keyframes baseGradientShift {
		0% {
			background-position: 0% 0%;
		}
		50% {
			background-position: 100% 100%;
		}
		100% {
			background-position: 0% 0%;
		}
	}

	/* Background image layer - on top of base background */
	.background-image-layer {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		width: 100%;
		height: 100%;
		background-size: cover;
		background-position: right bottom;
		background-repeat: no-repeat;
		transform-origin: right bottom;
		z-index: 1;
		pointer-events: none;
		transition: transform 0.15s linear;
	}

	/* ============================================
	   OVERLAY CUSTOMIZATION VARIABLES
	   Adjust these to fine-tune the overlay effect
	   
	   Breakpoints: xs(480) sm(640) md(768) lg(1024) xl(1280) 2xl(1536) 3xl(1920) 4xl(2560)
	   ============================================ */
	
	/* === BASE / MOBILE (default) === */
	:root {
		/* Overlay color: #b5d4e8 (primary color) */
		--overlay-color: 181, 212, 232;
		
		/* Full overlay (Section 0) */
		--full-direction: 135deg;
		--full-opacity-start: 0;
		--full-opacity-mid: 0;
		--full-opacity-end: 0;
		--full-stop-1: 0%;
		--full-stop-2: 50%;
		--full-stop-3: 100%;
		
		/* Gradient overlay (Section 1) */
		--grad-direction: 180deg;
		--grad-opacity-start: 1;
		--grad-opacity-mid: 0.8;
		--grad-opacity-end: 0;
		--grad-stop-1: 0%;
		--grad-stop-2: 35%;
		--grad-stop-3: 50%;
	}
	
	/* === xs: 480px === */
	@media (min-width: 480px) {
		:root {
			--grad-direction: 180deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 0%;
			--grad-stop-2: 35%;
			--grad-stop-3: 50%;
		}
	}
	
	/* === sm: 640px === */
	@media (min-width: 640px) {
		:root {
			--grad-direction: 180deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 0%;
			--grad-stop-2: 35%;
			--grad-stop-3: 50%;
		}
	}
	
	/* === md: 768px === */
	@media (min-width: 768px) {
		:root {
			--grad-direction: 180deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 0%;
			--grad-stop-2: 35%;
			--grad-stop-3: 50%;
		}
	}
	
	/* === lg: 1024px === */
	@media (min-width: 1024px) {
		:root {
			--grad-direction: 102deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 37%;
			--grad-stop-2: 44%;
			--grad-stop-3: 52%;
		}
	}
	
	/* === xl: 1280px === */
	@media (min-width: 1280px) {
		:root {
			--grad-direction: 100deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 38%;
			--grad-stop-2: 50%;
			--grad-stop-3: 62%;
		}
	}
	
	/* === 2xl: 1536px === */
	@media (min-width: 1536px) {
		:root {
			--grad-direction: 95deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 36%;
			--grad-stop-2: 50%;
			--grad-stop-3: 70%;
		}
	}
	
	/* === 3xl: 1920px === */
	@media (min-width: 1920px) {
		:root {
			--grad-direction: 95deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 40%;
			--grad-stop-2: 54%;
			--grad-stop-3: 76%;
		}
	}
	
	/* === 4xl: 2560px === */
	@media (min-width: 2560px) {
		:root {
			--grad-direction: 95deg;
			--grad-opacity-start: 1;
			--grad-opacity-mid: 0.8;
			--grad-opacity-end: 0;
			--grad-stop-1: 40%;
			--grad-stop-2: 54%;
			--grad-stop-3: 76%;
		}
	}
	
	/* === DARK MODE === */
	html.dark {
		--overlay-color: 15, 23, 42;
		
		--full-direction: 135deg;
		--full-opacity-start: 0.7;
		--full-opacity-mid: 0.5;
		--full-opacity-end: 0.4;
		--full-stop-1: 0%;
		--full-stop-2: 50%;
		--full-stop-3: 100%;
		
		--grad-direction: 180deg;
		--grad-opacity-start: 1;
		--grad-opacity-mid: 0.8;
		--grad-opacity-end: 0;
		--grad-stop-1: 0%;
		--grad-stop-1a: 17.5%;
		--grad-opacity-1a: 0.9;
		--grad-stop-2: 35%;
		--grad-stop-2a: 42.5%;
		--grad-opacity-2a: 0.4;
		--grad-stop-3: 50%;
	}
	
	/* Dark mode breakpoints */
	@media (min-width: 480px) {
		html.dark {
			--grad-direction: 180deg;
      --grad-opacity-start: 1;
      --grad-opacity-mid: 0.8;
      --grad-opacity-end: 0;
      --grad-stop-1: 0%;
      --grad-stop-1a: 17.5%;
      --grad-opacity-1a: 0.9;
      --grad-stop-2: 35%;
      --grad-stop-2a: 43.5%;
      --grad-opacity-2a: 0.6;
      --grad-stop-3: 60%;
		}
	}
	
	@media (min-width: 640px) {
		html.dark {
			--grad-direction: 180deg;
      --grad-opacity-start: 1;
      --grad-opacity-mid: 0.8;
      --grad-opacity-end: 0;
      --grad-stop-1: 0%;
      --grad-stop-1a: 17.5%;
      --grad-opacity-1a: 0.9;
      --grad-stop-2: 35%;
      --grad-stop-2a: 43.5%;
      --grad-opacity-2a: 0.6;
      --grad-stop-3: 60%;
		}
	}
	
	@media (min-width: 768px) {
		html.dark {
			--grad-direction: 180deg;
      --grad-opacity-start: 1;
      --grad-opacity-mid: 0.8;
      --grad-opacity-end: 0;
      --grad-stop-1: 0%;
      --grad-stop-1a: 17.5%;
      --grad-opacity-1a: 0.9;
      --grad-stop-2: 35%;
      --grad-stop-2a: 43.5%;
      --grad-opacity-2a: 0.6;
      --grad-stop-3: 60%;
		}
	}
	
	@media (min-width: 1024px) {
		html.dark {
			--grad-direction: 102deg;
      --grad-opacity-start: 0.8;
      --grad-opacity-mid: 0.6;
      --grad-opacity-end: 0;
      --grad-stop-1: 23%;
      --grad-stop-1a: 35%;
      --grad-opacity-1a: 0.715;
      --grad-stop-2: 47%;
      --grad-stop-2a: 65.5%;
      --grad-opacity-2a: 0.315;
      --grad-stop-3: 84%;
		}
	}
	
	@media (min-width: 1280px) {
		html.dark {
      --grad-direction: 100deg;
      --grad-opacity-start: 0.95;
      --grad-opacity-mid: 0.7;
      --grad-opacity-end: 0;
      --grad-stop-1: 14%;
      --grad-stop-1a: 27.5%;
      --grad-opacity-1a: 0.825;
      --grad-stop-2: 41%;
      --grad-stop-2a: 68%;
      --grad-opacity-2a: 0.35;
      --grad-stop-3: 95%;
		}
	}
	
	@media (min-width: 1536px) {
		html.dark {
      --grad-direction: 95deg;
      --grad-opacity-start: 0.96;
      --grad-opacity-mid: 0.7;
      --grad-opacity-end: 0;
      --grad-stop-1: 16%;
      --grad-stop-1a: 31%;
      --grad-opacity-1a: 0.83;
      --grad-stop-2: 46%;
      --grad-stop-2a: 70.5%;
      --grad-opacity-2a: 0.35;
      --grad-stop-3: 95%;
		}
	}
	
	@media (min-width: 1920px) {
		html.dark {
			--grad-direction: 95deg;
      --grad-opacity-start: 0.98;
      --grad-opacity-mid: 0.75;
      --grad-opacity-end: 0;
      --grad-stop-1: 31%;
      --grad-stop-1a: 44%;
      --grad-opacity-1a: 0.905;
      --grad-stop-2: 57%;
      --grad-stop-2a: 75.5%;
      --grad-opacity-2a: 0.415;
      --grad-stop-3: 94%;
		}
	}
	
	@media (min-width: 2560px) {
		html.dark {
			--grad-direction: 95deg;
      --grad-opacity-start: 1;
      --grad-opacity-mid: 0.74;
      --grad-opacity-end: 0;
      --grad-stop-1: 40%;
      --grad-stop-1a: 54%;
      --grad-opacity-1a: 0.87;
      --grad-stop-2: 60%;
      --grad-stop-2a: 69%;
      --grad-opacity-2a: 0.51;
      --grad-stop-3: 78%;
		}
	}

	/* Full overlay for Section 0 
	   Shape: linear-gradient (change to radial-gradient for circular effect)
	   For radial: replace "var(--full-direction)" with "circle at top left" */
	.overlay-full {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		z-index: 2;
		pointer-events: none;
		opacity: 1;
		transition: opacity 0.3s ease;
		background: linear-gradient(
			var(--full-direction),
			rgba(var(--overlay-color), var(--full-opacity-start)) var(--full-stop-1),
			rgba(var(--overlay-color), var(--full-opacity-mid)) var(--full-stop-2),
			rgba(var(--overlay-color), var(--full-opacity-end)) var(--full-stop-3)
		);
	}

	/* Gradient overlay for Section 1
	   Shape: linear-gradient (change to radial-gradient for circular effect)
	   For radial: replace "var(--grad-direction)" with "circle at left center" */
	.overlay-gradient {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		z-index: 2;
		pointer-events: none;
		opacity: 0;
		transition: opacity 0.3s ease;
		/* Uses deeper blue (#a8cce3 = 168, 204, 227) for all stops */
		--overlay-gradient-color: 168, 204, 227;
		background: linear-gradient(
			var(--grad-direction),
			rgba(var(--overlay-gradient-color), var(--grad-opacity-start)) var(--grad-stop-1),
			rgba(var(--overlay-gradient-color), var(--grad-opacity-1a, var(--grad-opacity-start))) var(--grad-stop-1a, var(--grad-stop-1)),
			rgba(var(--overlay-gradient-color), var(--grad-opacity-mid)) var(--grad-stop-2),
			rgba(var(--overlay-gradient-color), var(--grad-opacity-2a, var(--grad-opacity-mid))) var(--grad-stop-2a, var(--grad-stop-2)),
			rgba(var(--overlay-gradient-color), var(--grad-opacity-end)) var(--grad-stop-3)
		);
	}

	html.dark .overlay-gradient {
		--overlay-gradient-color: 7, 13, 23;
	}


	.scroll-panel {
		min-height: 100vh;
		width: 100%;
		display: flex;
		align-items: flex-start;
		justify-content: flex-start;
		position: relative;
		z-index: 10;
	}

	/* Override default section fade for this experience */
	.scroll-panel .section {
		opacity: 1 !important;
		transform: none !important;
	}

	/* ============================================
	   MOBILE CARD STACKING EFFECT (â‰¤1024px)
	   - Sections 0-1 (Hero, About): Original behavior with background image
	   - Section 2+ (Skills onward): Card stacking effect
	   ============================================ */
	@media (max-width: 1024px) {
		#scroll-root {
			height: auto !important;
		}

		.scroll-stage {
			height: auto !important;
			overflow: visible;
			position: relative;
		}

		/* Background layers - FIXED position so they stay visible behind sections 0-1 */
		.base-background {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 0;
		}

		.background-image-layer {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 1;
		}

		.overlay-full {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 2;
		}

		.overlay-gradient {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 3;
		}

		/* Base scroll-panel styles */
		.scroll-panel {
			min-height: 100vh;
			position: relative;
		}

		/* ========== SECTION 0 (Hero) - Original behavior ========== */
		.scroll-panel#home,
		.scroll-panel:nth-child(1) {
			background: transparent;
			position: relative;
			z-index: 10;
		}

		.scroll-panel#home .section,
		.scroll-panel#home .container,
		.scroll-panel#home .hero,
		.scroll-panel:nth-child(1) .section,
		.scroll-panel:nth-child(1) .container {
			background: transparent !important;
		}

		/* ========== SECTION 1 (About) - Sticky behavior with tolerance ========== */
		.scroll-panel#about,
		.scroll-panel:nth-child(2) {
			background: transparent;
			position: sticky;
			top: 0;
			z-index: 11;
			/* Tolerance area - extra height for scrolling before next section covers */
			margin-bottom: 30vh;
		}

		.scroll-panel#about .section,
		.scroll-panel#about .container,
		.scroll-panel:nth-child(2) .section,
		.scroll-panel:nth-child(2) .container {
			background: transparent !important;
		}

		/* ========== SECTION 2+ (Skills onward) - Card stacking ========== */
		.scroll-panel:nth-child(n+3) {
			position: sticky;
			top: 0;
			background: var(--bg-primary);
			/* Shadow for depth effect as cards stack */
			box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.08), 0 -2px 8px rgba(0, 0, 0, 0.04);
			/* Rounded top corners for card effect */
			border-top-left-radius: 20px;
			border-top-right-radius: 20px;
		}

		html.dark .scroll-panel:nth-child(n+3) {
			box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.3), 0 -2px 8px rgba(0, 0, 0, 0.2);
		}

		/* Z-index stacking for card sections (starting from section 2) */
		.scroll-panel:nth-child(3) { z-index: 30; }  /* Skills */
		.scroll-panel:nth-child(4) { z-index: 40; }  /* Projects */
		.scroll-panel:nth-child(5) { z-index: 50; }  /* Timeline */
		.scroll-panel:nth-child(6) { z-index: 60; }  /* Contact */
		.scroll-panel:nth-child(7) { z-index: 70; }
		.scroll-panel:nth-child(8) { z-index: 80; }

		/* Ensure card sections have solid background */
		.scroll-panel:nth-child(n+3) .section,
		.scroll-panel:nth-child(n+3) .container {
			background: var(--bg-primary);
			border-top-left-radius: 20px;
			border-top-right-radius: 20px;
		}

		/* Timeline section */
		#timeline {
			background: var(--bg-primary);
			position: sticky;
			top: 0;
			box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.08);
			border-top-left-radius: 20px;
			border-top-right-radius: 20px;
		}

		html.dark #timeline {
			box-shadow: 0 -8px 30px rgba(0, 0, 0, 0.3);
		}

		/* Ensure proper stacking for content visibility */
		.scroll-panel .section {
			position: relative;
		}
	}

	/* Test animated ball for scroll progress */
	.scroll-progress-ball {
		position: fixed;
		top: 50px;
		left: 0;
		width: 60px;
		height: 60px;
		border-radius: 50%;
		background: var(--accent-primary);
		box-shadow: 0 0 20px rgba(100, 116, 139, 0.3);
		z-index: 9999;
		pointer-events: none;
		transform: translate(0, 0);
		opacity: 0.8;
	}

	html.dark .scroll-progress-ball {
		box-shadow: 0 0 20px rgba(96, 165, 250, 0.3);
	}
</style>
