---
import SectionTitle from './SectionTitle.astro';
import { getTimelineEntries, formatTimelineDate } from '../utils/timeline';

const timelineEntries = await getTimelineEntries();

const { class: className } = Astro.props;
---

<section
	id="timeline"
	class=`${className} timeline-horizontal scroll-panel flex min-h-screen w-full items-start justify-start`
	data-timeline-entries={timelineEntries.length}
>
	<div class="container">
		<SectionTitle number="05" title="Journey Timeline" />

		<!-- DESKTOP: Horizontal Timeline -->
		<div class="timeline-container desktop-timeline">
			<!-- Timeline Track -->
			<div class="timeline-track">
				<!-- Clean horizontal bar -->
				<div class="timeline-bar"></div>

				<!-- Scroll-based glow on the bar -->
				<div class="bar-glow" id="bar-glow"></div>

				<!-- Vertical glow beam reaching up to text -->
				<div class="vertical-glow" id="vertical-glow"></div>

				<!-- Year labels above the bar -->
				<div class="timeline-points">
					{timelineEntries.map((entry, index) => (
						<div
							class="timeline-point"
							data-index={index}
							data-year={entry.date}
						>
							<span class="point-year">{formatTimelineDate(entry.date)}</span>
						</div>
					))}
				</div>
			</div>

			<!-- Content Display Area -->
			<div class="timeline-content-wrapper">
				{timelineEntries.map((entry, index) => {
					const EntryContent = entry.Content;
					return (
						<div
							class="timeline-content-panel"
							data-index={index}
						>
							<div class="content-card">
								<div class="content-header">
									<div class="content-meta">
										<span class="content-category">{entry.category}</span>
										<span class="content-date">{formatTimelineDate(entry.date)}</span>
									</div>
									<h2 class="content-title">{entry.title}</h2>
								</div>
								<div class="content-body">
									{EntryContent && <EntryContent />}
								</div>
							</div>
						</div>
					);
				})}
			</div>
		</div>

		<!-- MOBILE: Vertical Sections with Progress Tracking -->
		<div class="timeline-container mobile-timeline">
			{timelineEntries.map((entry, index) => {
				const EntryContent = entry.Content;
				return (
					<div class="timeline-section" data-index={index} data-year={entry.date}>
						<!-- Fixed header with year + progress bar -->
						<div class="timeline-section-header">
							<div class="header-content">
								<span class="section-year">{formatTimelineDate(entry.date)}</span>
								<div class="section-progress-bar">
									<div class="section-progress-fill" data-section={index}></div>
								</div>
							</div>
						</div>
						
						<!-- Scrollable content for this year -->
						<div class="timeline-section-content">
							<div class="content-card">
								<div class="content-header">
									<div class="content-meta">
										<span class="content-category">{entry.category}</span>
									</div>
									<h2 class="content-title">{entry.title}</h2>
								</div>
								<div class="content-body">
									{EntryContent && <EntryContent />}
								</div>
							</div>
						</div>
					</div>
				);
			})}
		</div>
	</div>
</section>

<style>
  .timeline-bg {
		background: rgba(255, 255, 255, 0.25);
		backdrop-filter: blur(16px);
		-webkit-backdrop-filter: blur(16px);
		border-radius: 20px;
		border: 1px solid rgba(255, 255, 255, 0.35);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
		transition: all 0.3s ease;
	}

	html.dark .timeline-bg {
		background: rgba(30, 41, 59, 0.35);
		border: 1px solid rgba(148, 163, 184, 0.15);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);
	}
	.timeline-horizontal {
		position: relative;
		overflow: visible;
	}

	.timeline-container {
		position: relative;
		padding: 3rem 0 6rem;
		min-height: 200vh;
	}

	/* Timeline Track */
	.timeline-track {
		position: sticky;
		top: 80px;
		width: 100%;
		height: 100px;
		margin-bottom: 5rem;
		display: flex;
		align-items: center;
		z-index: 10;
		background: transparent;
		position: relative;
	}

	/* Clean horizontal bar */
	.timeline-bar {
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		height: 2px;
		width: 100%;
		background: linear-gradient(
			90deg,
			transparent,
			rgba(255, 255, 255, 0.2) 3%,
			rgba(255, 255, 255, 0.2) 97%,
			transparent
		);
		z-index: 1;
	}

	html.dark .timeline-bar {
		background: linear-gradient(
			90deg,
			transparent,
			rgba(148, 163, 184, 0.2) 3%,
			rgba(148, 163, 184, 0.2) 97%,
			transparent
		);
	}

	/* Glow on the bar (scroll-based) */
	.bar-glow {
		position: absolute;
		top: 50%;
		transform: translate(-50%, -50%);
		width: 30px;
		height: 30px;
		border-radius: 50%;
		background: radial-gradient(
			circle,
			rgba(255, 140, 60, 0.6),
			rgba(255, 140, 60, 0.3) 40%,
			transparent 70%
		);
		filter: blur(12px);
		opacity: 0;
		z-index: 2;
		pointer-events: none;
		transition: opacity 0.3s ease;
	}

	.bar-glow.active {
		opacity: 1;
	}

	/* Vertical beam of light reaching up from bar to text */
	.vertical-glow {
		position: absolute;
		top: 50%;
		transform: translate(-50%, -100%);
		width: 2px;
		height: 30px;
		background: linear-gradient(
			to top,
			rgba(255, 140, 60, 0.6),
			rgba(255, 140, 60, 0.3) 50%,
			transparent
		);
		filter: blur(8px);
		opacity: 0;
		z-index: 2;
		pointer-events: none;
		transition: opacity 0.3s ease;
	}

	.vertical-glow.active {
		opacity: 1;
	}

	/* Year points container */
	.timeline-points {
		position: relative;
		width: 100%;
		display: flex;
		justify-content: space-between;
		align-items: flex-end;
		z-index: 3;
		padding: 0 2rem;
		padding-bottom: 2rem;
	}

	.timeline-point {
		position: relative;
		display: flex;
		flex-direction: column;
		align-items: center;
		flex: 1;
	}

	/* Year labels positioned above the bar */
	.point-year {
		font-size: 0.875rem;
		font-weight: 300;
		color: var(--text-tertiary);
		font-family: 'Inter', sans-serif;
		letter-spacing: 0.05em;
		white-space: nowrap;
		transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
		text-shadow: 0 0 0 transparent;
	}

	/* Glow effect on text when light reaches it */
	.timeline-point.glowing .point-year {
		color: #ff8c3c;
		font-weight: 500;
		transform: translateY(-3px);
		text-shadow: 0 0 15px rgba(255, 140, 60, 0.5),
					 0 0 25px rgba(255, 140, 60, 0.2);
	}

	/* Active content state (from scroll) */
	.timeline-point.active .point-year {
		color: var(--text-primary);
		font-weight: 400;
	}

	/* Content Display - Card-based design */
	.timeline-content-wrapper {
		position: relative;
		min-height: 600px;
	}

	.timeline-content-panel {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		opacity: 0;
		transform: translateY(30px);
		pointer-events: none;
		transition: opacity 0.5s ease, transform 0.5s ease;
	}

	.timeline-content-panel.active {
		opacity: 1;
		transform: translateY(0);
		pointer-events: all;
	}

	/* Content card - matches Skills glassmorphism style */
	.content-card {
		background: rgba(255, 255, 255, 0.25);
		backdrop-filter: blur(16px);
		-webkit-backdrop-filter: blur(16px);
		padding: 3rem;
		border-radius: 20px;
		border: 1px solid rgba(255, 255, 255, 0.35);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
		transition: all 0.3s ease;
	}

	html.dark .content-card {
		background: rgba(30, 41, 59, 0.35);
		border: 1px solid rgba(148, 163, 184, 0.15);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);
	}

	.content-header {
		margin-bottom: 2.5rem;
		padding-bottom: 2rem;
		border-bottom: 1px solid rgba(255, 255, 255, 0.2);
	}

	html.dark .content-header {
		border-bottom-color: rgba(148, 163, 184, 0.1);
	}

	.content-meta {
		display: flex;
		gap: 1rem;
		margin-bottom: 1.5rem;
		flex-wrap: wrap;
		align-items: center;
	}

	/* Category tag - glassmorphism pill */
	.content-category {
		font-size: 0.875rem;
		color: var(--text-primary);
		background: rgba(255, 255, 255, 0.4);
		backdrop-filter: blur(8px);
		-webkit-backdrop-filter: blur(8px);
		padding: 0.5rem 1.25rem;
		border-radius: 100px;
		border: 1px solid rgba(255, 255, 255, 0.5);
		text-transform: capitalize;
		font-weight: 400;
		letter-spacing: 0.02em;
	}

	html.dark .content-category {
		background: rgba(30, 41, 59, 0.5);
		border: 1px solid rgba(148, 163, 184, 0.2);
	}

	.content-date {
		font-size: 0.875rem;
		color: #ff8c3c;
		font-weight: 500;
		font-family: 'JetBrains Mono', 'Menlo', 'Consolas', monospace;
		letter-spacing: 0.02em;
	}

	/* Title with serif font like other headers */
	.content-title {
		font-family: 'Libre Baskerville', serif;
		font-size: clamp(2rem, 4vw, 2.5rem);
		font-weight: 300;
		color: var(--text-primary);
		line-height: 1.3;
		margin: 0;
		letter-spacing: -0.01em;
		padding-left: 1rem;
		border-left: 3px solid #ff8c3c;
	}

	/* Content body - clean typography */
	.content-body {
		color: var(--text-secondary);
		line-height: 1.8;
		font-size: 1.0625rem;
		font-weight: 300;
	}

	.content-body :global(p) {
		margin-bottom: 1.5rem;
		line-height: 1.8;
	}

	.content-body :global(h2),
	.content-body :global(h3) {
		font-family: 'Libre Baskerville', serif;
		color: var(--text-primary);
		margin-top: 2.5rem;
		margin-bottom: 1.25rem;
		font-size: 1.375rem;
		font-weight: 400;
		letter-spacing: -0.01em;
	}

	.content-body :global(h2:first-child),
	.content-body :global(h3:first-child) {
		margin-top: 0;
	}

	.content-body :global(ul),
	.content-body :global(ol) {
		margin-left: 1.75rem;
		margin-bottom: 1.5rem;
	}

	.content-body :global(li) {
		margin-bottom: 0.875rem;
		line-height: 1.7;
	}

	.content-body :global(strong) {
		color: var(--text-primary);
		font-weight: 500;
	}

	/* Responsive Design */
	@media (max-width: 1024px) {
		.timeline-track {
			top: 100px;
			height: 90px;
			margin-bottom: 4rem;
		}

		.timeline-points {
			padding: 0 1rem;
			padding-bottom: 1.5rem;
		}

		.point-year {
			font-size: 0.8rem;
		}

		.content-card {
			padding: 2.5rem;
		}

		.bar-glow {
			width: 24px;
			height: 24px;
			filter: blur(10px);
		}

		.vertical-glow {
			height: 25px;
			filter: blur(6px);
		}
	}

	@media (max-width: 768px) {
		.timeline-track {
			height: 80px;
			margin-bottom: 3rem;
			top: 80px;
		}

		.timeline-points {
			overflow-x: auto;
			scroll-snap-type: x mandatory;
			-webkit-overflow-scrolling: touch;
			padding-bottom: 1.5rem;
			scrollbar-width: none;
			justify-content: flex-start;
			gap: 3rem;
			padding-left: 1.5rem;
			padding-right: 1.5rem;
		}

		.timeline-points::-webkit-scrollbar {
			display: none;
		}

		.timeline-point {
			flex-shrink: 0;
			scroll-snap-align: center;
			flex: 0 0 auto;
		}

		.point-year {
			font-size: 0.75rem;
		}

		.timeline-content-wrapper {
			min-height: 500px;
		}

		.content-card {
			padding: 2rem;
			border-radius: 16px;
		}

		.content-title {
			font-size: 1.75rem;
		}

		.content-body {
			font-size: 1rem;
		}

		.bar-glow {
			width: 20px;
			height: 20px;
			filter: blur(8px);
		}

		.vertical-glow {
			height: 20px;
			filter: blur(5px);
		}
	}

	@media (max-width: 480px) {
		.timeline-points {
			gap: 2.5rem;
		}

		.point-year {
			font-size: 0.7rem;
		}

		.content-card {
			padding: 1.75rem;
		}

		.content-header {
			margin-bottom: 2rem;
			padding-bottom: 1.5rem;
		}

		.bar-glow {
			width: 18px;
			height: 18px;
			filter: blur(7px);
		}

		.vertical-glow {
			height: 18px;
			filter: blur(4px);
		}
	}

	/* ========================================
	   MOBILE TIMELINE: Vertical Sections
	   ======================================== */

	/* Hide mobile timeline on desktop */
	.mobile-timeline {
		display: none;
	}

	@media (max-width: 1024px) {
		/* Show mobile, hide desktop */
		.desktop-timeline {
			display: none;
		}
		
		.mobile-timeline {
			display: block;
			padding: 0;
			min-height: auto;
		}
		
		/* Each year = one full-screen section */
		.timeline-section {
			min-height: 100vh;
			position: relative;
			padding-top: 120px; /* Space for fixed header */
			padding-bottom: 4rem;
		}
		
		/* Fixed header per section */
		.timeline-section-header {
			position: sticky;
			top: 70px; /* Below main navbar (hidden on mobile) */
			z-index: 100;
			background: rgba(255, 255, 255, 0.95);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			padding: 1.5rem 0;
			margin: 0 -1rem; /* Extend to edges */
			border-bottom: 1px solid rgba(0, 0, 0, 0.05);
		}
		
		html.dark .timeline-section-header {
			background: rgba(15, 23, 42, 0.95);
			border-bottom-color: rgba(148, 163, 184, 0.1);
		}
		
		.header-content {
			max-width: 100%;
			padding: 0 1rem;
		}
		
		/* Year label - prominent */
		.section-year {
			display: block;
			font-size: 1.125rem;
			font-weight: 500;
			color: var(--text-primary);
			font-family: 'JetBrains Mono', monospace;
			letter-spacing: 0.05em;
			margin-bottom: 1rem;
		}
		
		/* Minimalist progress line */
		.section-progress-bar {
			height: 3px;
			background: rgba(0, 0, 0, 0.1);
			position: relative;
			overflow: hidden;
			border-radius: 2px;
		}
		
		html.dark .section-progress-bar {
			background: rgba(148, 163, 184, 0.2);
		}
		
		/* Animated fill (controlled by GSAP) */
		.section-progress-fill {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 0%; /* GSAP animates this */
			background: linear-gradient(90deg, #ff8c3c, #ff6b3c);
			border-radius: 2px;
			transition: width 0.05s linear; /* Smooth but responsive */
		}
		
		/* Scrollable content area */
		.timeline-section-content {
			min-height: 60vh; /* Ensure enough scroll distance */
			padding-bottom: 2rem;
		}
		
		/* Reuse existing content-card styles */
		.timeline-section .content-card {
			margin-top: 2rem;
		}
	}

	@media (max-width: 768px) {
		.timeline-section {
			padding-top: 100px;
		}
		
		.timeline-section-header {
			top: 60px;
			padding: 1rem 0;
		}
		
		.section-year {
			font-size: 1rem;
		}
	}
</style>

<script>
	// @ts-nocheck
	import gsap from 'gsap';
	import ScrollTrigger from 'gsap/ScrollTrigger';
	
	gsap.registerPlugin(ScrollTrigger);
	
	const isMobile = () => window.innerWidth <= 1024;
	
	// ========================================
	// DESKTOP TIMELINE: Global progress listener
	// ========================================
	function initDesktopTimeline() {
		if (isMobile()) {
			console.log('[Timeline] Mobile mode - skipping desktop timeline');
			return;
		}
		
		console.log('[Timeline] Desktop mode - initializing horizontal timeline');
		
		const timelinePoints = document.querySelectorAll('.timeline-point');
		const contentPanels = document.querySelectorAll('.timeline-content-panel');
		const barGlow = document.getElementById('bar-glow');
		const verticalGlow = document.getElementById('vertical-glow');
		const timelineTrack = document.querySelector('.timeline-track');

		const totalEntries = timelinePoints.length;
		let currentActiveIndex = 0;

		// Get the actual positions of timeline points
		function getPointPositions() {
			const trackRect = timelineTrack?.getBoundingClientRect();
			if (!trackRect) return [];

			return Array.from(timelinePoints).map((point) => {
				const rect = point.getBoundingClientRect();
				// Calculate position as percentage along the timeline
				const centerX = rect.left + rect.width / 2;
				const relativeX = centerX - trackRect.left;
				const percentage = (relativeX / trackRect.width) * 100;
				return {
					element: point,
					position: Math.max(0, Math.min(100, percentage))
				};
			});
		}

		let pointPositions = getPointPositions();

		// Update positions on resize
		window.addEventListener('resize', () => {
			pointPositions = getPointPositions();
		});

		// Handle timeline updates based on scroll progress
		function updateTimeline(progress) {
			const clamped = Math.max(0, Math.min(1, progress));

			// Position the glow based on scroll progress
			const glowPosition = clamped * 100; // Convert to percentage

			if (barGlow && verticalGlow) {
				barGlow.style.left = `${glowPosition}%`;
				verticalGlow.style.left = `${glowPosition}%`;

				// Show glows when scrolling through timeline
				if (progress > 0 && progress < 1) {
					barGlow.classList.add('active');
					verticalGlow.classList.add('active');
				} else {
					barGlow.classList.remove('active');
					verticalGlow.classList.remove('active');
				}
			}

			// Calculate which point is closest to the glow
			const glowRadius = 5; // 5% radius for glow effect

			pointPositions.forEach(({ element, position }) => {
				const distance = Math.abs(glowPosition - position);

				if (distance < glowRadius) {
					// Fade in as approaching, peak at center, fade out as leaving
					const intensity = 1 - (distance / glowRadius);
					if (intensity > 0.3) {
						element.classList.add('glowing');
					} else {
						element.classList.remove('glowing');
					}
				} else {
					element.classList.remove('glowing');
				}
			});

			// Handle content panel switching
			const segmentSize = 1 / totalEntries;
			let activeIndex = 0;

			for (let i = 0; i < totalEntries; i++) {
				const segmentStart = i * segmentSize;
				const segmentEnd = (i + 1) * segmentSize;
				const threshold = segmentSize * 0.05;

				if (clamped >= segmentStart - threshold && clamped < segmentEnd) {
					activeIndex = i;
					break;
				}
			}

			activeIndex = Math.min(activeIndex, totalEntries - 1);

			timelinePoints.forEach((point, index) => {
				point.classList.remove('active');
				if (index === activeIndex) {
					point.classList.add('active');
				}
			});

			if (activeIndex !== currentActiveIndex) {
				contentPanels.forEach((panel, index) => {
					panel.classList.toggle('active', index === activeIndex);
				});
				currentActiveIndex = activeIndex;
			}
		}

		updateTimeline(0);

		// Listen to global timeline progress event
		window.addEventListener('timelineprogress', (e) => {
			const detail = e.detail || {};
			if (typeof detail.progress === 'number') {
				updateTimeline(detail.progress);
			}
		});
	}
	
	// ========================================
	// MOBILE TIMELINE: Per-section ScrollTriggers
	// ========================================
	function initMobileTimeline() {
		if (!isMobile()) {
			console.log('[Timeline] Desktop mode - skipping mobile timeline');
			return;
		}
		
		console.log('[Timeline] Mobile mode - initializing vertical sections');
		
		const sections = document.querySelectorAll('.timeline-section');
		const triggers = []; // Store triggers for cleanup
		
		sections.forEach((section, index) => {
			const progressFill = section.querySelector('.section-progress-fill');
			const year = section.dataset.year;
			
			if (!progressFill) {
				console.warn(`[Timeline] No progress fill found for section ${index}`);
				return;
			}
			
			console.log(`[Timeline] Creating ScrollTrigger for section ${index} (${year})`);
			
			// Create ScrollTrigger for this section
			const trigger = ScrollTrigger.create({
				trigger: section,
				start: 'top 70px', // When section header reaches sticky position
				end: 'bottom 70px', // When section bottom passes sticky position
				scrub: 0.3, // Smooth animation with slight delay
				onUpdate: (self) => {
					// Animate progress line 0% → 100% as user scrolls through section
					const progress = self.progress * 100;
					progressFill.style.width = `${progress}%`;
					
					// Debug log (can be removed in production)
					if (Math.abs(progress - 0) < 1 || Math.abs(progress - 100) < 1 || progress % 25 < 1) {
						console.log(`[Timeline] Section ${index} (${year}): ${progress.toFixed(1)}%`);
					}
				},
				onEnter: () => {
					console.log(`[Timeline] Entered section ${index} (${year})`);
				},
				onLeave: () => {
					console.log(`[Timeline] Left section ${index} (${year})`);
				},
				markers: false // Set to true for debugging
			});
			
			triggers.push(trigger);
		});
		
		console.log(`[Timeline] Created ${triggers.length} mobile ScrollTriggers`);
		
		// Store triggers for cleanup
		return triggers;
	}
	
	// ========================================
	// INITIALIZATION & MODE SWITCHING
	// ========================================
	let mobileScrollTriggers = [];
	
	function initTimeline() {
		// Clean up any existing triggers
		if (mobileScrollTriggers.length > 0) {
			console.log('[Timeline] Cleaning up existing ScrollTriggers');
			mobileScrollTriggers.forEach(trigger => trigger.kill());
			mobileScrollTriggers = [];
		}
		
		// Initialize based on viewport
		if (isMobile()) {
			const triggers = initMobileTimeline();
			if (triggers) {
				mobileScrollTriggers = triggers;
			}
		} else {
			initDesktopTimeline();
		}
	}
	
	// Wait for DOM and GSAP
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initTimeline);
	} else {
		initTimeline();
	}
	
	// Handle resize (reinitialize on desktop ↔ mobile switch)
	let currentMode = isMobile() ? 'mobile' : 'desktop';
	let resizeTimeout;
	
	window.addEventListener('resize', () => {
		// Debounce resize events
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(() => {
			const newMode = isMobile() ? 'mobile' : 'desktop';
			
			if (newMode !== currentMode) {
				console.log(`[Timeline] Mode switch detected: ${currentMode} → ${newMode}`);
				currentMode = newMode;
				
				// Reinitialize for new mode
				initTimeline();
			}
		}, 250); // 250ms debounce
	});
</script>
