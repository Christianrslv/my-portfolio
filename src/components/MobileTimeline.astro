---
import SectionTitle from './SectionTitle.astro';
import { getTimelineEntries, formatTimelineDate } from '../utils/timeline';

const timelineEntries = await getTimelineEntries();

const { class: className } = Astro.props;
---

<section
	id="mobile-timeline"
	class=`${className} timeline-horizontal scroll-panel lg:hidden scroll-panel flex min-h-screen w-full items-center justify-center z-80! bg-(--bg-primary)`
	data-timeline-entries={timelineEntries.length}
>
	<div class="max-w-full relative pt-0!">
    <!-- Fixed header with year + progress bar -->
    <div class="journey-timeline-header sticky top-0 pt-6 z-10 flex flex-col gap-1 pb-4 h-full">
      <SectionTitle number="05" title="Journey Timeline" />
        <div class="timeline-section-header">
          <div class="header-content flex flex-col gap-2">
            <div class="flex justify-between">
              <span class="section-year-current font-serif">{formatTimelineDate('2019')}</span>
              <span class="section-year-next font-serif">{formatTimelineDate('2022')}</span>
            </div>
            <div class="flex w-full">
              <div class="section-progress-bar w-full flex gap-2">
                <div class="section-progress-fill rounded-none!" data-section={0}></div>
              </div>
            </div>
          </div>
        </div>
    </div>
		<!-- MOBILE: Vertical Sections with Progress Tracking -->
     <div class="container">
       <div class="timeline-container mobile-timeline flex flex-col gap-4">
         {timelineEntries.map((entry, index) => {
           const EntryContent = entry.Content;
           return (
             <div class="flex items-center justify-center pb-10">
               <span class="text-5xl font-serif">{formatTimelineDate(entry.date)}</span>
             </div>
           
             <div class="timeline-section pb-40" data-index={index} data-year={entry.date} data-next-year={timelineEntries[index + 1]?.date}>
               <!-- Scrollable content for this year -->
               <div class="timeline-section-content">
                 <div class="content-card">
                   <div class="content-header">
                     <div class="content-meta">
                       <span class="content-category">{entry.category}</span>
                     </div>
                     <h2 class="content-title">{entry.title}</h2>
                   </div>
                   <div class="content-body">
                     {EntryContent && <EntryContent />}
                   </div>
                 </div>
               </div>
             </div>
           );
         })}
       </div>
     </div>
	</div>
</section>

<style>
  .journey-timeline-header::before {
		content: '';
		position: absolute;
		top: 0;
    left: 0;
    right: 0;
    height: 120%;
		background: transparent;
		backdrop-filter: blur(12px);
		-webkit-backdrop-filter: blur(12px);
		mask-image: linear-gradient(to bottom, black 0%, black 70%, transparent 100%);
		-webkit-mask-image: linear-gradient(to bottom, black 0%, black 70%, transparent 100%);
		z-index: -1;
    border-radius: 20px 20px 0 0;
	}
  .timeline-bg {
		background: rgba(255, 255, 255, 0.25);
		backdrop-filter: blur(16px);
		-webkit-backdrop-filter: blur(16px);
		border-radius: 20px;
		border: 1px solid rgba(255, 255, 255, 0.35);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
		transition: all 0.3s ease;
	}

	html.dark .timeline-bg {
		background: rgba(30, 41, 59, 0.35);
		border: 1px solid rgba(148, 163, 184, 0.15);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);
	}
	.timeline-horizontal {
		position: relative;
		overflow: visible;
	}

	.timeline-container {
		position: relative;
		padding: 3rem 0 6rem;
		min-height: 200vh;
	}

	/* Timeline Track */
	.timeline-track {
		position: sticky;
		top: 80px;
		width: 100%;
		height: 100px;
		margin-bottom: 5rem;
		display: flex;
		align-items: center;
		z-index: 10;
		background: transparent;
		position: relative;
	}

	/* Clean horizontal bar */
	.timeline-bar {
		position: absolute;
		left: 0;
		top: 50%;
		transform: translateY(-50%);
		height: 2px;
		width: 100%;
		background: linear-gradient(
			90deg,
			transparent,
			rgba(255, 255, 255, 0.2) 3%,
			rgba(255, 255, 255, 0.2) 97%,
			transparent
		);
		z-index: 1;
	}

	html.dark .timeline-bar {
		background: linear-gradient(
			90deg,
			transparent,
			rgba(148, 163, 184, 0.2) 3%,
			rgba(148, 163, 184, 0.2) 97%,
			transparent
		);
	}

	/* Glow on the bar (scroll-based) */
	.bar-glow {
		position: absolute;
		top: 50%;
		transform: translate(-50%, -50%);
		width: 30px;
		height: 30px;
		border-radius: 50%;
		background: radial-gradient(
			circle,
			rgba(255, 140, 60, 0.6),
			rgba(255, 140, 60, 0.3) 40%,
			transparent 70%
		);
		filter: blur(12px);
		opacity: 0;
		z-index: 2;
		pointer-events: none;
		transition: opacity 0.3s ease;
	}

	.bar-glow.active {
		opacity: 1;
	}

	/* Vertical beam of light reaching up from bar to text */
	.vertical-glow {
		position: absolute;
		top: 50%;
		transform: translate(-50%, -100%);
		width: 2px;
		height: 30px;
		background: linear-gradient(
			to top,
			rgba(255, 140, 60, 0.6),
			rgba(255, 140, 60, 0.3) 50%,
			transparent
		);
		filter: blur(8px);
		opacity: 0;
		z-index: 2;
		pointer-events: none;
		transition: opacity 0.3s ease;
	}

	.vertical-glow.active {
		opacity: 1;
	}

	/* Year points container */
	.timeline-points {
		position: relative;
		width: 100%;
		display: flex;
		justify-content: space-between;
		align-items: flex-end;
		z-index: 3;
		padding: 0 2rem;
		padding-bottom: 2rem;
	}

	.timeline-point {
		position: relative;
		display: flex;
		flex-direction: column;
		align-items: center;
		flex: 1;
	}

	/* Year labels positioned above the bar */
	.point-year {
		font-size: 0.875rem;
		font-weight: 300;
		color: var(--text-tertiary);
		font-family: 'Inter', sans-serif;
		letter-spacing: 0.05em;
		white-space: nowrap;
		transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
		text-shadow: 0 0 0 transparent;
	}

	/* Glow effect on text when light reaches it */
	.timeline-point.glowing .point-year {
		color: #ff8c3c;
		font-weight: 500;
		transform: translateY(-3px);
		text-shadow: 0 0 15px rgba(255, 140, 60, 0.5),
					 0 0 25px rgba(255, 140, 60, 0.2);
	}

	/* Active content state (from scroll) */
	.timeline-point.active .point-year {
		color: var(--text-primary);
		font-weight: 400;
	}

	/* Content Display - Card-based design */
	.timeline-content-wrapper {
		position: relative;
		min-height: 600px;
	}

	.timeline-content-panel {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		opacity: 0;
		transform: translateY(30px);
		pointer-events: none;
		transition: opacity 0.5s ease, transform 0.5s ease;
	}

	.timeline-content-panel.active {
		opacity: 1;
		transform: translateY(0);
		pointer-events: all;
	}

	/* Content card - matches Skills glassmorphism style */
	.content-card {
		background: rgba(255, 255, 255, 0.25);
		backdrop-filter: blur(16px);
		-webkit-backdrop-filter: blur(16px);
		padding: 3rem;
		border-radius: 20px;
		border: 1px solid rgba(255, 255, 255, 0.35);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
		transition: all 0.3s ease;
	}

	html.dark .content-card {
		background: rgba(30, 41, 59, 0.35);
		border: 1px solid rgba(148, 163, 184, 0.15);
		box-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);
	}

	.content-header {
		margin-bottom: 2.5rem;
		padding-bottom: 2rem;
		border-bottom: 1px solid rgba(255, 255, 255, 0.2);
	}

	html.dark .content-header {
		border-bottom-color: rgba(148, 163, 184, 0.1);
	}

	.content-meta {
		display: flex;
		gap: 1rem;
		margin-bottom: 1.5rem;
		flex-wrap: wrap;
		align-items: center;
	}

	/* Category tag - glassmorphism pill */
	.content-category {
		font-size: 0.875rem;
		color: var(--text-primary);
		background: rgba(255, 255, 255, 0.4);
		backdrop-filter: blur(8px);
		-webkit-backdrop-filter: blur(8px);
		padding: 0.5rem 1.25rem;
		border-radius: 100px;
		border: 1px solid rgba(255, 255, 255, 0.5);
		text-transform: capitalize;
		font-weight: 400;
		letter-spacing: 0.02em;
	}

	html.dark .content-category {
		background: rgba(30, 41, 59, 0.5);
		border: 1px solid rgba(148, 163, 184, 0.2);
	}

	.content-date {
		font-size: 0.875rem;
		color: #ff8c3c;
		font-weight: 500;
		font-family: 'JetBrains Mono', 'Menlo', 'Consolas', monospace;
		letter-spacing: 0.02em;
	}

	/* Title with serif font like other headers */
	.content-title {
		font-family: 'Libre Baskerville', serif;
		font-size: clamp(2rem, 4vw, 2.5rem);
		font-weight: 300;
		color: var(--text-primary);
		line-height: 1.3;
		margin: 0;
		letter-spacing: -0.01em;
		padding-left: 1rem;
		border-left: 3px solid #ff8c3c;
	}

	/* Content body - clean typography */
	.content-body {
		color: var(--text-secondary);
		line-height: 1.8;
		font-size: 1.0625rem;
		font-weight: 300;
	}

	.content-body :global(p) {
		margin-bottom: 1.5rem;
		line-height: 1.8;
	}

	.content-body :global(h2),
	.content-body :global(h3) {
		font-family: 'Libre Baskerville', serif;
		color: var(--text-primary);
		margin-top: 2.5rem;
		margin-bottom: 1.25rem;
		font-size: 1.375rem;
		font-weight: 400;
		letter-spacing: -0.01em;
	}

	.content-body :global(h2:first-child),
	.content-body :global(h3:first-child) {
		margin-top: 0;
	}

	.content-body :global(ul),
	.content-body :global(ol) {
		margin-left: 1.75rem;
		margin-bottom: 1.5rem;
	}

	.content-body :global(li) {
		margin-bottom: 0.875rem;
		line-height: 1.7;
	}

	.content-body :global(strong) {
		color: var(--text-primary);
		font-weight: 500;
	}

	/* Responsive Design */
	@media (max-width: 1024px) {
		.timeline-track {
			top: 100px;
			height: 90px;
			margin-bottom: 4rem;
		}

		.timeline-points {
			padding: 0 1rem;
			padding-bottom: 1.5rem;
		}

		.point-year {
			font-size: 0.8rem;
		}

		.content-card {
			padding: 2.5rem;
		}

		.bar-glow {
			width: 24px;
			height: 24px;
			filter: blur(10px);
		}

		.vertical-glow {
			height: 25px;
			filter: blur(6px);
		}
	}

	@media (max-width: 768px) {
		.timeline-track {
			height: 80px;
			margin-bottom: 3rem;
			top: 80px;
		}

		.timeline-points {
			overflow-x: auto;
			scroll-snap-type: x mandatory;
			-webkit-overflow-scrolling: touch;
			padding-bottom: 1.5rem;
			scrollbar-width: none;
			justify-content: flex-start;
			gap: 3rem;
			padding-left: 1.5rem;
			padding-right: 1.5rem;
		}

		.timeline-points::-webkit-scrollbar {
			display: none;
		}

		.timeline-point {
			flex-shrink: 0;
			scroll-snap-align: center;
			flex: 0 0 auto;
		}

		.point-year {
			font-size: 0.75rem;
		}

		.timeline-content-wrapper {
			min-height: 500px;
		}

		.content-card {
			padding: 2rem;
			border-radius: 16px;
		}

		.content-title {
			font-size: 1.75rem;
		}

		.content-body {
			font-size: 1rem;
		}

		.bar-glow {
			width: 20px;
			height: 20px;
			filter: blur(8px);
		}

		.vertical-glow {
			height: 20px;
			filter: blur(5px);
		}
	}

	@media (max-width: 480px) {
		.timeline-points {
			gap: 2.5rem;
		}

		.point-year {
			font-size: 0.7rem;
		}

		.content-card {
			padding: 1.75rem;
		}

		.content-header {
			margin-bottom: 2rem;
			padding-bottom: 1.5rem;
		}

		.bar-glow {
			width: 18px;
			height: 18px;
			filter: blur(7px);
		}

		.vertical-glow {
			height: 18px;
			filter: blur(4px);
		}
	}

	/* ========================================
	   MOBILE TIMELINE: Vertical Sections
	   ======================================== */

	/* Hide mobile timeline on desktop */
	.mobile-timeline {
		display: none;
	}

	@media (max-width: 1024px) {
		/* Show mobile, hide desktop */
		.desktop-timeline {
			display: none;
		}
		
		.mobile-timeline {
			display: block;
			padding: 0;
			min-height: auto;
		}
		
		/* Each year = one full-screen section */
		.timeline-section {
			/* min-height: 100vh; */
			position: relative;
			/* padding-top: 120px; Space for fixed header */
			/* padding-bottom: 4rem; */
		}
		
		html.dark .timeline-section-header {
			border-bottom-color: rgba(148, 163, 184, 0.1);
		}
		
		.header-content {
			max-width: 100%;
			padding: 0 1rem;
		}
		
		/* Year label - prominent */
		.section-year-current, .section-year-next {
			display: block;
			font-size: 1.125rem;
			font-weight: 500;
			color: var(--text-primary);
			/* font-family: var(--font-libre-baskerville); */
			letter-spacing: 0.05em;
		}
		
		/* Minimalist progress line */
		.section-progress-bar {
			height: 3px;
			background: rgba(0, 0, 0, 0.1);
			position: relative;
			overflow: hidden;
			border-radius: 2px;
		}
		
		html.dark .section-progress-bar {
			background: rgba(148, 163, 184, 0.2);
		}
		
		/* Animated fill (controlled by GSAP) */
		.section-progress-fill {
			position: absolute;
			left: 0;
			top: 0;
			height: 100%;
			width: 0%; /* GSAP animates this */
			background: linear-gradient(90deg, #ff8c3c, #ff6b3c);
			border-radius: 2px;
			transition: width 0.05s linear; /* Smooth but responsive */
		}
		
		/* Scrollable content area */
		.timeline-section-content {
			min-height: 60vh; /* Ensure enough scroll distance */
		}
		
	}
</style>

<script>
	// @ts-nocheck
	import gsap from 'gsap';
	import ScrollTrigger from 'gsap/ScrollTrigger';
	
	gsap.registerPlugin(ScrollTrigger);
	
	const isMobile = () => window.innerWidth <= 1024;
	
	// ========================================
	// MOBILE TIMELINE: Per-section ScrollTriggers
	// ========================================
	function initMobileTimeline() {
		if (!isMobile()) {
			console.log('[Timeline] Desktop mode - skipping mobile timeline');
			return;
		}
		
		console.log('[Timeline] Mobile mode - initializing vertical sections');
		
		const sections = document.querySelectorAll('.timeline-section');
		const triggers = []; // Store triggers for cleanup
    const progressFill = document.querySelector('.section-progress-fill');
		const sectionYearCurrent = document.querySelector('.section-year-current');
		const sectionYearNext = document.querySelector('.section-year-next');
    

		sections.forEach((section, index) => {
			let year = section.dataset.year;
			let nextYear = section.dataset.nextYear;
			console.log(`[Timeline] Year: ${year}`);
			if (!progressFill) {
				console.warn(`[Timeline] No progress fill found for section ${index}`);
				return;
			}
			// console.log(`[Timeline] Creating ScrollTrigger for section ${index} (${year})`);	
			// Create ScrollTrigger for this section
			const trigger = ScrollTrigger.create({
				trigger: section,
				start: 'top 50%', // When section header reaches sticky position
				end: 'bottom 50%', // When section bottom passes sticky position
				scrub: 0.3, // Smooth animation with slight delay
				onUpdate: (self) => {
					// Animate progress line 0% → 100% as user scrolls through section
					const progress = self.progress * 100;
					progressFill.style.width = `${progress}%`;
					
					// Debug log (can be removed in production)
					// if (Math.abs(progress - 0) < 1 || Math.abs(progress - 100) < 1 || progress % 25 < 1) {
					// 	console.log(`[Timeline] Section ${index} (${year}): ${progress.toFixed(1)}%`);
					// }

          // Update year display when entering a new section
          if (sectionYearCurrent && sectionYearCurrent.textContent !== year) {
            sectionYearCurrent.textContent = year;
            sectionYearNext.textContent = nextYear;
            // console.log(`[Timeline] Updated year display to: ${year}`);
          }

				},
				onEnter: () => {
					// console.log(`[Timeline] Entered section ${index} (${year})`);
				},
				onLeave: () => {
					// console.log(`[Timeline] Left section ${index} (${year})`);
				},
				markers: false // Set to true for debugging
			});
			
			triggers.push(trigger);
		});
		
		console.log(`[Timeline] Created ${triggers.length} mobile ScrollTriggers`);
		
		// Store triggers for cleanup
		return triggers;
	}
	
	// ========================================
	// INITIALIZATION & MODE SWITCHING
	// ========================================
	let mobileScrollTriggers = [];
	
	function initTimeline() {
		// Clean up any existing triggers
		if (mobileScrollTriggers.length > 0) {
			console.log('[Timeline] Cleaning up existing ScrollTriggers');
			mobileScrollTriggers.forEach(trigger => trigger.kill());
			mobileScrollTriggers = [];
		}
		
		// Initialize based on viewport
		if (isMobile()) {
			const triggers = initMobileTimeline();
			if (triggers) {
				mobileScrollTriggers = triggers;
			}
		}
	}
	
	// Wait for DOM and GSAP
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initTimeline);
	} else {
		initTimeline();
	}
	
	// Handle resize (reinitialize on desktop ↔ mobile switch)
	let currentMode = isMobile() ? 'mobile' : 'desktop';
	let resizeTimeout;
	
	window.addEventListener('resize', () => {
		// Debounce resize events
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(() => {
			const newMode = isMobile() ? 'mobile' : 'desktop';
			
			if (newMode !== currentMode) {
				console.log(`[Timeline] Mode switch detected: ${currentMode} → ${newMode}`);
				currentMode = newMode;
				
				// Reinitialize for new mode
				initTimeline();
			}
		}, 250); // 250ms debounce
	});
</script>
